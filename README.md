# Bisection_method_Fortran

このプログラムはメインプログラムとサブプログラム（サブルーチンと副関数）に分かれています。まずメインプログラムについて説明します。

メインプログラムには最初に実数としてx1、x2、accuracy、answer、整数としてerror、文字型配列としてactionを設定しています。ここでx1とx2は二分法におけるxの二つの値であり、accuracyはどこまで近似を行うかを決定するための精度値で、answerは二分法を実行した時のxの答えです。errorはエラーの種類を分別するために使用し、actionはエラー後の計算の終了や続行を決めるために使われます。

次にエラー検出を行うためにerrorを0に設定し、精度値を1.0e-9（意味は1.0×10^−9）に設定します。その後区間x1、x2を設定し、ターミナルからx1、x2を設定できるようにします。

その後、callを用いて自分で作ったbisection関数を呼び出し計算します。この時、errorは0、1、2の三種類に分けられます。error=0は計算が無事に完了したというエラーコードで、error=1というのはx1とx2の符号が同じであったため二分法の計算を行うことができないというエラーコードです。error=2というのは計算の回答が精度を満たさなかったことを意味します。

ここでselect関数を用いてそれぞれのエラーコードについて場合分けを行います。まずerror=1の時はエラーの説明として「x1とx2が同じ符号であるため二分法の計算ができない」と表示し、その後計算を続行するかどうかの判断について、まずは「もし計算を終了したい場合はexitと入力してください。」「終了したくない場合はdoと入力してください」をターミナルから表示させ、ターミナルからdoまたはexitを入力し、その情報をactionに保管します。

ここで、もしexitとターミナルに入力したら計算が終了し、「計算終了しました。」と表示され、doと入力した場合は計算が続行します。計算実行の場合はもう一度x1とx2を読み込み、call関数を用いてもう一度計算します。この時にもしエラーコード0の場合は0003のラベルの結果表示のプログラムに行き、エラーコード1の場合は0001のラベルに行き、エラーコード2の場合は0002のラベルに行きます。error=2の時のエラーの説明はerror=1とほぼ同じです。

まずは「求める解は完璧な解ではないが、その解と近い解を求めた」と表示し、その近い解を表示します。その後計算を続行するかどうかの判断について、まずは「もし計算を終了したい場合はexitと入力してください。」「終了したくない場合はdoと入力してください」をターミナルから表示させ、ターミナルからdoまたはexitを入力し、その情報をactionに保管します。

ここでもしexitとターミナルに入力したら計算が終了し、「計算終了しました。」と表示され、doと入力した場合は計算が続行します。計算実行の場合はもう一度x1とx2を読み込み、call関数を用いてもう一度計算します。この時にもしエラーコード0の場合は0003のラベルの結果表示のプログラムに行き、エラーコード1の場合は0001のラベルに行き、エラーコード2の場合は0002のラベルに行きます。

ここで0001、0002、0003について説明します。0001については前のプログラムにおいてもう一度計算し、その時のエラーコードが1の時に実行されるプログラムです。そのプログラムはselect関数中のcase(1)の内容とほぼ同じで、同符号で計算不可とターミナルに表示させた後に、計算継続するかどうかの判断におけるdoまたはexitを読み取り、exitの場合は前と同じく計算を終了させます。doの場合はもう一度x1とx2を読み取り、計算し、計算結果におけるエラーコードによりもう一度0001、0002または0003のラベルに行きます。

0002については前のプログラムにおいてもう一度計算し、その時のエラーコードが2の時に実行されるプログラムです。そのプログラムはselect関数中のcase(2)の内容とほぼ同じで、解の精度が満たされていないとターミナルに表示させた後に、計算継続するかどうかの判断におけるdoまたはexitを読み取り、exitの場合は前と同じく計算を終了させます。doの場合はもう一度x1とx2を読み取り、計算し、計算結果におけるエラーコードによりもう一度0001、0002または0003のラベルに行きます。

0003については全プログラムにおいてエラーコードが0の時に実行されるプログラムであり、解の答えであるanswerを表示するとともに「計算終了しました」と表示されます。

サブプログラムについて説明します。サブプログラムには二分法の手順が書いてあるサブルーチン、名前bisectionや関数を定義する関数副プログラムfuncが存在します。まずサブルーチンbisectionについて説明します。ここではメインプログラムで定義した関数のほかに、実数型であるf1、f2、xp、xn、xmid、fmidや整数型であるi、nが定義されています。

サブルーチンbisectionではまずcall関数を用いて定義した副関数funcを呼び出し、x1やx2を代入し結果としてそれぞれf1とf2が帰ってきます。ここでもしf1とf2の掛け算が正、つまりf1とf2が同符号の場合は二分法の計算ができないため、error=1と設定し、returnを用いてメインプログラムに返します。

f1が0の場合、x1が解となるため、answer=x1、error=0と設定し、returnを用いてメインプログラムへ返します。f2が0の場合、x2が解となるため、answer=x2、error=0と設定し、returnを用いてメインプログラムへ返します。ここで正と負の値の判断をわかりやすくするためにxpとxnを設定します。もしf1が正の場合はxp=x1、xn=x2であり、逆の場合はxp=x2、xn=x1となります。

次に二分法の計算回数nをターミナルから入力し設定します。そしてdo構文を用いて二分法の計算を実行します。具体的にはxpとxnの中間値を取り、その中間値をxmidとします。この中間値をfuncに代入し、返した値をfmidとします。この時、if構文を用いてfmidが正である時、xp=xmidとし、fmidが負である時、xn=xmidとします。そしてfmid=0である時はxmidが解となり、answer=xmidとしてreturnを用いてメインプログラムへその値を返します。

その後新しく設定されたxpまたはxnを用いてもう一度xmidを計算し、fmidを求めます。そのような操作をn回振り返します。もしその時xpとxnの差の絶対値であるABS(xp-xn)がメインプログラムで設定したaccuracy（精度値）である1.0e-9よりも小さい場合は、xpとxnの中間値が求める答えであると近似を行うことができ、answer=xmidとしreturnを用いてメインプログラムへその値を返します。もし計算をn回実行しても差の絶対値が精度値以上であった場合、この時answerはanswer=xmidとして解を返しますが、エラーコードが2として設定されます。

次に関数副プログラムfuncについて説明します。実数型でx、fを設定し、f=という形で=の後ろにxの関数を関数副プログラムに入力します。そこで「gfortran ファイル名」をターミナルから入力し、実行ファイルを作ります。
